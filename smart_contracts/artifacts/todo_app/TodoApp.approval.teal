#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 0 8
    bytecblock 0x151f7c75 "todo_counter" "todos" "completed" 0x000e546f646f206e6f7420666f756e64
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/todo_app/contract.py:11-12
    // # Counter to track total number of todos created
    // self.todo_counter = GlobalState(UInt64(0))
    bytec_1 // "todo_counter"
    intc_1 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/todo_app/contract.py:4
    // class TodoApp(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@15
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x38011815 0x447f8198 0xc45b3ab4 0xc274afc2 0xfe5825e9 0x77363853 // method "create_todo(string)uint64", method "complete_todo(uint64)string", method "get_todo(uint64)string", method "is_completed(uint64)bool", method "get_total_todos()uint64", method "delete_todo(uint64)string"
    txna ApplicationArgs 0
    match create_todo complete_todo get_todo is_completed get_total_todos delete_todo
    err

main___algopy_default_create@15:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_0 // 1
    return


// smart_contracts.todo_app.contract.TodoApp.create_todo[routing]() -> void:
create_todo:
    // smart_contracts/todo_app/contract.py:18
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/todo_app/contract.py:24-25
    // # Increment the counter to get new todo ID
    // current_id = self.todo_counter.value
    intc_1 // 0
    bytec_1 // "todo_counter"
    app_global_get_ex
    assert // check self.todo_counter exists
    // smart_contracts/todo_app/contract.py:26
    // new_id = current_id + UInt64(1)
    intc_0 // 1
    +
    // smart_contracts/todo_app/contract.py:27
    // self.todo_counter.value = new_id
    bytec_1 // "todo_counter"
    dig 1
    app_global_put
    // smart_contracts/todo_app/contract.py:29-30
    // # Store the todo task
    // todo_id = arc4.UInt64(new_id)
    itob
    // smart_contracts/todo_app/contract.py:31
    // self.todos[todo_id] = task
    bytec_2 // "todos"
    dig 1
    concat
    dup
    box_del
    pop
    uncover 2
    box_put
    // smart_contracts/todo_app/contract.py:32
    // self.completed[todo_id] = arc4.Bool(False)
    bytec_3 // "completed"
    dig 1
    concat
    pushbytes 0x00
    box_put
    // smart_contracts/todo_app/contract.py:18
    // @arc4.abimethod()
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.todo_app.contract.TodoApp.complete_todo[routing]() -> void:
complete_todo:
    // smart_contracts/todo_app/contract.py:36
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dupn 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/todo_app/contract.py:42-43
    // # Check if todo exists
    // if todo_id not in self.todos:
    bytec_2 // "todos"
    swap
    concat
    box_len
    bury 1
    bnz complete_todo_after_if_else@3
    // smart_contracts/todo_app/contract.py:44
    // return arc4.String("Todo not found")
    bytec 4 // 0x000e546f646f206e6f7420666f756e64

complete_todo_after_inlined_smart_contracts.todo_app.contract.TodoApp.complete_todo@4:
    // smart_contracts/todo_app/contract.py:36
    // @arc4.abimethod()
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

complete_todo_after_if_else@3:
    // smart_contracts/todo_app/contract.py:46-47
    // # Mark as completed
    // self.completed[todo_id] = arc4.Bool(True)
    bytec_3 // "completed"
    dig 1
    concat
    pushbytes 0x80
    box_put
    // smart_contracts/todo_app/contract.py:49
    // return arc4.String("Todo marked as completed!")
    pushbytes 0x0019546f646f206d61726b656420617320636f6d706c6574656421
    // smart_contracts/todo_app/contract.py:36
    // @arc4.abimethod()
    b complete_todo_after_inlined_smart_contracts.todo_app.contract.TodoApp.complete_todo@4


// smart_contracts.todo_app.contract.TodoApp.get_todo[routing]() -> void:
get_todo:
    // smart_contracts/todo_app/contract.py:51
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/todo_app/contract.py:57
    // if todo_id not in self.todos:
    bytec_2 // "todos"
    swap
    concat
    dup
    box_len
    bury 1
    bnz get_todo_after_if_else@3
    // smart_contracts/todo_app/contract.py:58
    // return arc4.String("Todo not found")
    bytec 4 // 0x000e546f646f206e6f7420666f756e64

get_todo_after_inlined_smart_contracts.todo_app.contract.TodoApp.get_todo@4:
    // smart_contracts/todo_app/contract.py:51
    // @arc4.abimethod()
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

get_todo_after_if_else@3:
    // smart_contracts/todo_app/contract.py:60
    // return self.todos[todo_id]
    dup
    box_get
    assert // check self.todos entry exists
    // smart_contracts/todo_app/contract.py:51
    // @arc4.abimethod()
    b get_todo_after_inlined_smart_contracts.todo_app.contract.TodoApp.get_todo@4


// smart_contracts.todo_app.contract.TodoApp.is_completed[routing]() -> void:
is_completed:
    // smart_contracts/todo_app/contract.py:62
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/todo_app/contract.py:68
    // if todo_id not in self.completed:
    bytec_3 // "completed"
    swap
    concat
    dup
    box_len
    bury 1
    bnz is_completed_after_if_else@3
    // smart_contracts/todo_app/contract.py:69
    // return arc4.Bool(False)
    pushbytes 0x00

is_completed_after_inlined_smart_contracts.todo_app.contract.TodoApp.is_completed@4:
    // smart_contracts/todo_app/contract.py:62
    // @arc4.abimethod()
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

is_completed_after_if_else@3:
    // smart_contracts/todo_app/contract.py:71
    // return self.completed[todo_id]
    dup
    box_get
    assert // check self.completed entry exists
    // smart_contracts/todo_app/contract.py:62
    // @arc4.abimethod()
    b is_completed_after_inlined_smart_contracts.todo_app.contract.TodoApp.is_completed@4


// smart_contracts.todo_app.contract.TodoApp.get_total_todos[routing]() -> void:
get_total_todos:
    // smart_contracts/todo_app/contract.py:78
    // return arc4.UInt64(self.todo_counter.value)
    intc_1 // 0
    bytec_1 // "todo_counter"
    app_global_get_ex
    assert // check self.todo_counter exists
    itob
    // smart_contracts/todo_app/contract.py:73
    // @arc4.abimethod()
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.todo_app.contract.TodoApp.delete_todo[routing]() -> void:
delete_todo:
    // smart_contracts/todo_app/contract.py:80
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dupn 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/todo_app/contract.py:86
    // if todo_id not in self.todos:
    bytec_2 // "todos"
    swap
    concat
    dup
    box_len
    bury 1
    bnz delete_todo_after_if_else@3
    // smart_contracts/todo_app/contract.py:87
    // return arc4.String("Todo not found")
    bytec 4 // 0x000e546f646f206e6f7420666f756e64

delete_todo_after_inlined_smart_contracts.todo_app.contract.TodoApp.delete_todo@4:
    // smart_contracts/todo_app/contract.py:80
    // @arc4.abimethod()
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

delete_todo_after_if_else@3:
    // smart_contracts/todo_app/contract.py:89-90
    // # Delete from both storage boxes
    // del self.todos[todo_id]
    dup
    box_del
    pop
    // smart_contracts/todo_app/contract.py:91
    // del self.completed[todo_id]
    bytec_3 // "completed"
    dig 2
    concat
    box_del
    pop
    // smart_contracts/todo_app/contract.py:93
    // return arc4.String("Todo deleted successfully!")
    pushbytes 0x001a546f646f2064656c65746564207375636365737366756c6c7921
    // smart_contracts/todo_app/contract.py:80
    // @arc4.abimethod()
    b delete_todo_after_inlined_smart_contracts.todo_app.contract.TodoApp.delete_todo@4
